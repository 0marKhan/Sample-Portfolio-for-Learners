<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Javascript</title>
    <script src="javascript.js"></script>
    <link rel="stylesheet" href="../learnings.css">
</head>

<body>
    <h1>JavaScript</h1>
    <a href="../learnings.html">Home</a>
    <a href="#foot">Footer</a>
    <h2>Operators- arithenatic, logical comparison</h2>

    <h3>Logical Operators and or not</h3>
    <ul>
        <h4>
            False if -
        </h4>
        <li>undefined</li>
        <li>null</li>
        <li>0</li>
        <li>"</li>
        <li>false</li>
        <p>All other are true</p>
    </ul>
    <h3>FUNCTIONS - declare and invoke(call)</h3>
    <h4>way of creating a function 1 - function Declaration</h4>
    <ol>
        <li>funcion keyword</li>
        <li>fun name </li>
        <li>parameter</li>
        <li>body</li>
        <li>EXAMPLE - function fnName(parameter){body}</li>
    </ol>
    <h4>way of creating a function 2 - function EXpression</h4>
    <ol>
        <li>keyword - let/var</li>
        <li>variable name</li>
        <li>function keyword- function</li>
        <li>parameter</li>
        <li>body</li>
        <li>EXAMPLE - let fnName = function(parameter){body}</li>
    </ol>
    <h4>Function - Parameters and Arguments</h4>
    <h4>Return Keyword</h4>
    <p>Let's say that I want to display the result of my function into the main webpage!

        We haven't talked about Dom manipulation, so spare me with that.

        I'm going to give you some some scenarios why this function is not performing the way we want it.

        That's the scenario, number one.

        And also, what about say that?

        Oh, no, I don't want this play my result into the page, but instead I want to display it inside an

        elect.

        How can we do that?

        In that way, we need what is called the return keyword, because a function with no return and only consol.log is
        not giving out anything.

        Its just printing the thing in console tab. <br> So the return keyword is used to exit a function and return a
        value to the caller.

        Here comes.

        So one point of return is it is used to exit a function.

        And then if a value is present in the return, it is going to give out to the variable we assign a function to

        The return keyword is essential for creating functions that return value.

        So without return keyword, function will only be able to perform actions but not return values to the caller.

        This would limit the usefulness of a functions and make them much less powerful.

        so when you return sommething from teh function, now you can use the returned value anywhere in the javascript
        to display on screen,lets say alert(fnName(argument)) and you can displlay the returned value in alert section
        of website. Thsts amazing
    </p>
    <h3>STRINGS</h3>
    <h4>Ways of creating a string</h4>
    <ol>
        <li>using string literal "" or '' </li>
        <li>using the constructor function i.e. <br> const name = new String("something"); <br> this will return a way
            different form of string proved in the javascript code snippet below:</li>
        <p>const myName = "John";<br>const firstName = new String("John");<br>const result = myName === firstName;<br>
            console.log(result);<br>This code will give false!!!Yeass, though John and John are similar, due to they are
            different forms of string literals! . but if you did <br>const result = myName == firstName;<br> instead the
            answer will be TRUE! because now the datatypes of "John" will not be matched instead just the string.</p>
    </ol>
    <h3>String Concatenation</h3>
    <ol>
        <li>using + operator : str1+str2</li>
        <li>using concat method : const result = str1.concat(str2);</li>
    </ol>
    <h3>JS Template Literals</h3>
    <ol>
        <li>String literals "" </li>
        <li>back tick literals- this is multiline string that is all the enters will be considered ``</li>
        <li>template string</li>
        <li>INTERPOLATION - to use a variable inside the string
            <ul>
                <li>Using ${} between strings <br> const welcome = "Good Morning ${name}";</li>
                <li>Using + Operator <br>const welcome = "Good morning" + name ;</li>
            </ul>
        </li>
    </ol>
    <h3>String length - it takes white spaces into consideration!</h3>
    <p>const str = "Hell ";<br> str.length;<br> this will give 12</p>
    <h3>Some String functions</h3>
    <ol>
        <li>trim - to remove white spacings</li>
        <li>toUpperCase</li>
        <li>toLowerCase</li>
        <li>indexOf</li>
        <li>split(ch,3) - to split every charachter in the string w a specific characther ch example: <br> str =
            "hobnbkbsf"; str.split("b"); <br>this will give ['ho', 'n', 'k', 'sf'] i.e. all b are splitted</li>
        <li>str.join("b");</li>
        <li>str.reverse(); - to reverse an array. <br> if you want ot reverse a string, 1) split it into array 2)
            reverse it 3) join it into a string!</li>
        <li>str.repeat(n); to repeat a str n number of times </li>
        <li>str.startsWith(ch); - to check if str starts with ch</li>
        <li>str.endsWith();</li>
        <li>str.includes(ch); - to check if str contains ch</li>
        <li>str.slice(n,m); takes n to m charachetes from str</li>
    </ol>
    <h3>String Comparison</h3>
    <ul>
        <li>true == 1</li>
        <li>a>z</li>
        <li>a>A</li>
        <li>a>1</li>
        <li></li>
    </ul>
    <h3>Arrays</h3>
    <h4>Methods of cerating Array</h4>
    <ul>
        <li>Using new keyword: <br>const arr_name = new Array();</li>
        <li>Using Array literal <br>const arr_name = [];</li>
    </ul>

    <li>Array can take any type of data type value</li>
    <h3>Array Methods</h3>
    <ol>
        <li>arr.push(); - add to the end</li>
        <li>arr.pop(); - remove from the end</li>
        <li>arr.unshift(); - add to the beginning</li>
        <li>arr.shift(); remove from the beginning</li>
        <li>arr.indexOf();</li>
        <li>arr.lastindexOf();</li>
        <li>arr.include() </li>
        <li>arr.reverse()</li>
        <li>Reduce Method -
            <ol>
                <li>A function that accepts upto 4 arguments, the reduce method calls the callbackfn function one time
                    for each element in the array</li>
                <li>Calls the specified callback function for all the elements in the array</li>
                <li>The return value of the callback function is the accumulated result, and is provided as an argument
                    in the next call to the callback function</li>
                <li>Return a single value</li>
                <li>Doesn't mutates the original array</li>
                <li>Syntax- <br>
                    arr.reduce(function(acc,currVal,currIdx,arr){},initialVal);</li>
                <li>const callback = (accumulator, currentValue, index) => { <br>
                    &nbsp; // return something here
                    <br> } <br>
                    const result = array.reduce(callback, initialValue)
                </li>
                <li>The previous return value is used as the next accumulator</li>
                <li>initialValue is the value you want to start with.
                    <br>accumulator is the value returned from the previous iteration. <br>It will be initialValue for
                    the first iteration. <br>
                    currentValue is array item in the current iteration.
                </li>
            </ol>
        </li>
        <li>Find Method
            <ol>
                <li>(method) Array(number).find(predicate: (value: number, index: number, obj: number[]) => unknown,
                    thisArg?: any): number | undefined (+1 overload)</li>
                <li>Returns the value of the first element in the array where predicate is true, and undefined
                    otherwise.</li>

                <li>@param predicate
                    find calls predicate once for each element of the array, in ascending order, until it finds one
                    where
                    predicate returns true. If such an element is found, find immediately returns that element value.
                    Otherwise, find returns undefined.</li>

                <li>@param thisArg
                    If provided, it will be used as the this value for each invocation of predicate. If it is not
                    provided,
                    undefined is used instead.</li>
                <li>array.find(function(currentValue, index, arr),thisValue)
                <li>currentValue Required.
                    The value of the current element.</li>
                <li>thisValue Optional. Default undefined.
                    A value passed to the function as its this valu</li>
        </li>

    </ol>
    </li>
    <li>Filter Method
        <p>same as find, but this returns an array of answers not just first outcome</p>
    </li>
    <p>Example <br>

        const arri = [2, 4, 5, 2, 4]; <br>

        const reduce = arri.reduce(function (acc, currVal) {<br>
        return acc + currVal + currVal;<br>
        }, 0);<br>

        const find = arri.find(function(elements){<br>
        return elements>4;<br>
        })<br>

        const filter = arri.filter(function(element){<br>
        return element> 2;<br>
        })</p>
    Answers <br>
    reduce = 34, find = 5, filter = [4,5,4]
    </ol>
    <h2>Objects</h2>
    <h3>Accessing Object Properties</h3>
    <p>const person = { name: 'johny', salary: 45452, hobby: ['dance','cooking']}; </p>
    <ol>
        <li>Using dot notation i.e. person.name </li>
        <li>Using Bracket notation i.e. person["name"]</li>
    </ol>
    <h3>Updating Object property</h3>
    <p>person.name = "whateve"</p>
    <p>person['name'] = 'wahhah' -> used widely since it is more dynamic
        <br>
        for example
        <br>
        let printObj = function(obj){
        for(let key in obj){
        console.log(`${key}: ${obj[key]}`);
        }
        }
        <br>
        is better than
        <br>
        let printObj = function(obj){
        for(let key in obj){
        console.log(`${key}: ${obj.name}`);
        console.log(`${key}: ${obj.age}`);
        <!-- ... and so on -->
        }
        }
    </p>

    <h3>
        Deleting Object property
    </h3>
    <p>use <br>
        delete person.name <br>
        that is it, done!
    </p>

    <h3>this keyword</h3>
    <p>in javasctipt 'this' keyword refers to immediate or parent object</p>
    <p>if you do console.log(this); randomly it will show global object that is Window </p>

    <h3>Iterating Over Objects</h3>
    <ol>
        <li>for in loop - for(let key in objectName){} <br>for(let key in person){
            console.log(key);
            }</li>
        <li>object.keys let ans = Object.keys(objectName); <br>let keys_array = Object.keys(person);
            console.log(keys_array); </li>
        <li>forEach - <br>keys_array.forEach(function(element){
            console.log(element)
            })
        </li>
        <li>object.values - Object.values(person)</li>
        <li>object.entries - Object.entries(person) <br>
            Example <br>
            let objentries = Object.entries(person);
            objentries.forEach(function([key,value]){
            console.log(`${key}: ${value}`);
            })</li>
    </ol>

    <h3>Math Objects</h3>
    <ol>
        <li>abs</li>
        <li>round</li>
        <li>ceil - upper val</li>
        <li>floor - removes decimal no.s</li>
        <li>sqrt</li>
        <li>pow</li>
        <li>min</li>
        <li>max</li>
        <li>random</li>
        <li>Formula for Random Number between two values: <br> Math.random() * (max-min + 1) + min</li>
    </ol>

    <h2>Data Mutation</h2>
    <h3>Array Methods</h3>
    <ol>
        <li>arr.forEach(function(item,index,array){})</li>
        <li></li>
    </ol>
    <h2>Array of Objects</h2>
    <p>An array made up of objects, hence the methods of this are different</p>
    <h3>functions:</h3>
    <ol>
        <li>forEach</li>
        <li>push(object)</li>
        <li>map()</li>
        <li>filter()</li>
        <li>reduce()</li>
    </ol>










    <div id="foot">

        Footer
    </div>
</body>

</html>